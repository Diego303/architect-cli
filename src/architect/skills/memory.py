"""
Procedural Memory -- Detection and persistence of corrections across sessions (v4-A4).

Detects when the user corrects the agent, persists corrections in
.architect/memory.md and automatically injects them into the system prompt
of future sessions.
"""

import re
from datetime import datetime
from pathlib import Path

import structlog

logger = structlog.get_logger()

CORRECTION_PATTERNS: list[tuple[str, str]] = [
    (r"no[,.]?\s+(usa|utiliza|haz|pon|cambia|es)\b", "direct_correction"),
    (r"(eso no|eso está mal|no es correcto|está mal)", "negation"),
    (r"(en realidad|realmente|de hecho)\b", "clarification"),
    (r"(debería ser|el correcto es|el comando es)\b", "should_be"),
    (r"(no funciona así|así no)\b", "wrong_approach"),
    (r"(siempre|nunca)\s+(usa|hagas|pongas)\b", "absolute_rule"),
]


class ProceduralMemory:
    """Memory of corrections and patterns that persists across sessions."""

    MEMORY_FILE = ".architect/memory.md"

    def __init__(self, workspace_root: str):
        self.root = Path(workspace_root)
        self.memory_path = self.root / self.MEMORY_FILE
        self._entries: list[dict[str, str]] = []
        self._load()

    def _load(self) -> None:
        """Load existing entries from file."""
        if not self.memory_path.exists():
            return
        content = self.memory_path.read_text(encoding="utf-8")
        for match in re.finditer(
            r"^- \[(\d{4}-\d{2}-\d{2})\]\s*(\w+):\s*(.+)$",
            content,
            re.MULTILINE,
        ):
            self._entries.append({
                "date": match.group(1),
                "type": match.group(2),
                "content": match.group(3),
            })

    def detect_correction(
        self,
        user_msg: str,
        prev_agent_action: str | None = None,
    ) -> str | None:
        """Detect if the user message is a correction.

        Args:
            user_msg: User message.
            prev_agent_action: Previous agent action (for future context).

        Returns:
            The detected correction, or None if it is not a correction.
        """
        user_lower = user_msg.lower().strip()
        for pattern, correction_type in CORRECTION_PATTERNS:
            if re.search(pattern, user_lower):
                correction = self._extract_correction(user_msg, correction_type)
                if correction:
                    return correction
        return None

    def _extract_correction(self, msg: str, correction_type: str) -> str:
        """Extract the useful part of a correction."""
        msg = msg.strip()
        if len(msg) > 300:
            msg = msg[:300] + "..."
        return msg

    def add_correction(self, correction: str) -> None:
        """Add a correction to the memory file.

        Args:
            correction: Text of the correction to persist.
        """
        # Check for duplicate
        existing = [e["content"] for e in self._entries]
        if correction in existing:
            return

        entry = {
            "date": datetime.now().strftime("%Y-%m-%d"),
            "type": "Correction",
            "content": correction,
        }
        self._entries.append(entry)
        self._append_to_file(entry)
        logger.info("memory_correction_saved", content=correction[:100])

    def add_pattern(self, pattern: str) -> None:
        """Add a discovered pattern.

        Args:
            pattern: Text of the pattern to persist.
        """
        existing = [e["content"] for e in self._entries]
        if pattern in existing:
            return

        entry = {
            "date": datetime.now().strftime("%Y-%m-%d"),
            "type": "Pattern",
            "content": pattern,
        }
        self._entries.append(entry)
        self._append_to_file(entry)

    def _append_to_file(self, entry: dict[str, str]) -> None:
        """Append an entry to the markdown file."""
        self.memory_path.parent.mkdir(parents=True, exist_ok=True)
        if not self.memory_path.exists():
            self.memory_path.write_text(
                "# Project Memory\n\n"
                "> Auto-generated by architect. Manually editable.\n\n",
                encoding="utf-8",
            )
        with open(self.memory_path, "a", encoding="utf-8") as f:
            f.write(f"- [{entry['date']}] {entry['type']}: {entry['content']}\n")

    def get_context(self) -> str:
        """Return the memory content to inject into the prompt.

        Returns:
            String with the memory context, or "" if there is nothing.
        """
        if not self.memory_path.exists():
            return ""
        content = self.memory_path.read_text(encoding="utf-8")
        if len(content.strip()) < 10:
            return ""
        return f"\n## Project Memory (previous corrections)\n\n{content}\n"

    @property
    def entries(self) -> list[dict[str, str]]:
        """Return the loaded memory entries."""
        return list(self._entries)

    def analyze_session_learnings(
        self,
        conversation: list[dict[str, str]],
    ) -> list[str]:
        """Post-session: analyze conversation and extract corrections.

        Args:
            conversation: List of conversation messages.

        Returns:
            List of corrections detected and saved.
        """
        corrections_found: list[str] = []
        for i, msg in enumerate(conversation):
            if msg.get("role") == "user" and i > 0:
                content = msg.get("content", "")
                correction = self.detect_correction(content)
                if correction:
                    self.add_correction(correction)
                    corrections_found.append(correction)
        return corrections_found
